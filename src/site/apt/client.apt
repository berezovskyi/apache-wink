 -----
 Symphony Client
 -----
 -----
 June 2008

~~
~~ Licensed to the Apache Software Foundation (ASF) under one
~~ or more contributor license agreements.  See the NOTICE file
~~ distributed with this work for additional information
~~ regarding copyright ownership.  The ASF licenses this file
~~ to you under the Apache License, Version 2.0 (the
~~ "License"); you may not use this file except in compliance
~~ with the License.  You may obtain a copy of the License at
~~ 
~~ http://www.apache.org/licenses/LICENSE-2.0
~~ 
~~ Unless required by applicable law or agreed to in writing,
~~ software distributed under the License is distributed on an
~~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
~~ KIND, either express or implied.  See the License for the
~~ specific language governing permissions and limitations
~~ under the License.
~~

Symphony Client
 
  The Symphony Client is a Java based library that provides functionality for communicating with Rest based web services. 
  The library is built on top of the JDK HttpURLConnection and adds essential features that facilitate the development of client applications.
  
  * Supports the IETF Atom Syndication Format and Atom Publishing Protocol standards (RFC's 4287 and 5023).

  * The ability to intercept the message flow by means of custom Handlers.
  
  * Streaming data transfer (send & receive)
  
  * Proxy configuration (overrides system configuration settings)
  
  * Https connection (based on system configuration)
  
  * Automatic Http GET/PUT/POST/DELETE Redirect
  
  * Integration with HP LWSSO mechanism

  []

* API

  The Client API documentation is located in the{{{symphony-client/apidocs/index.html}here}} folder.
  
* Consuming a Service

  This section provides example applications that demonstrate how the Symphony Client is used to interact with Rest web services.
  
  * {{{Hello_World_Example}Hello World Example}}
  
  * {{{Hello_World_Example_2}Hello World Example 2}}
  
  * {{{Google_Blogger_Example}Google Blogger Example}}
  
  * {{{Introspection_of_an_Atom_Service_Document}Introspection of an Atom Service Document}}
  
  * {{{Exploring_Atom_Feed_and_Atom_Entry}Exploring Atom Feed and Atom Entry}}
  
  []
 
  Key steps that occur in each example application:

   [[1]] Creates a RestClient that is the central anchor point for all interactions with services
   
   [[]] Defines the resource that requires interaction
   
   [[]] Invokes a method on a resource and specifies the response representation
   
   [[]] Processes the results

   []

** {Hello World Example}
  
  In this example application the user will interact with a very simple Rest service that is located at the following URL,
  <<<http://services.com/rest/HelloWorld>>> which returns "Hello World" in plain text (<<<Hello World>>>) or in 
  XML (<<<\<quote\>Hello World\<\\quote\>>>>).
	
+--------------------------------------
// create the rest client instance
RestClient client = new RestClient();
// create the resource instance to interact with
Resource resource = client.newResource("http://services.com/rest/HelloWorld");
// perform a GET on the resource. the resource will be returned as plain text
Response<TextEntity> response = resource.doGet(TextEntity.class);
TextEntity text = response.getEntity();
System.out.println(text.getText());
+--------------------------------------

  The output of the above snippet is  <<<Hello World>>>

** {Hello World Example 2}
  
  In this example application the user will interact with the same Hello World service, but will change the actual message that the service returns. 
  In order to perform this, assume that the service can receive the new message and return it as plain text.
  
+--------------------------------------
// create the rest client instance
RestClient client = new RestClient();
// create the resource instance to interact with
Resource resource = client.newResource("http://services.com/rest/HelloWorld");
// perform a PUT to the resource.
// the message that the service will now be returning will be changed to "Hello World 2"
TextEntity newMessage = new TextEntity();
newMessage.setText("Hello World 2");
Response<XmlEntity> response = resource.doPut(newMessage, XmlEntity.class);
TextEntity text = response.getEntity();
System.out.println(text.getText());  
+--------------------------------------

  The output of the above example application is <<<\<quote\>Hello World 2\</quote\>>>>. Notice that plain text was sent, and received as XML.

** {Google Blogger Example}

  The following is a more realistic example, interacting with Google Blogger service.\
  In this example we will:
  
  [[1]] Retrieve a list of Blogs (as an Atom Feed) for a particular user
  
  [[]] Authenticate the user against the "GoogleLogin" service
  
  [[]] Post a new blog entry as the authenticated user
  
  []
  
  The following code snippet shows how to retrieve a list of Blogs (as an Atom Feed). 
  For more details about Google Blog Feed refer to 
  {{{http://code.google.com/apis/blogger/developers_guide_protocol.html#GettingBlogs}Google Developers Guide}}
  
+-----------------------------------------
import org.hp.symphony.rest.client.RestClient;
import org.hp.symphony.rest.client.Resource;
import org.hp.symphony.rest.client.entities.AtomFeedEntity;
import org.hp.symphony.rest.client.entities.AtomEntryEntity;
import org.hp.symphony.rest.model.atom.AtomFeed;
import org.hp.symphony.rest.model.atom.AtomEntry;
import org.hp.symphony.rest.model.atom.AtomText;

...

static String userId = "01869598636926391541";
static String url = "http://www.blogger.com/feeds/" + userId + "/blogs";

// Create Rest Client
RestClient restClient = new RestClient();

// Get a list of Blogs (in a form of an Atom Feed)
// First - create new Resource that represents a Feed of Blogs by a given URL
Resource picasablogs = restClient.newResource(url);

// Second - sent Http Get request to retrieve the Feed
Response<AtomFeedEntity> response = picasablogs.doGet(AtomFeedEntity.class);
AtomFeed blogs = response.getEntity().getFeed();

// Now you can work with each blog entry
List<AtomEntry> entries = blogs.getEntry();
for (AtomEntry atomEntry : entries) {
   // Work with single Blog Entry...
}
+-----------------------------------------

  Now lets see how to post a new entry
  
+-----------------------------------------
// Create a blog entry to publish in form of an Atom Entry
AtomEntryEntity myBlogEntryEntity = new AtomEntryEntity();
AtomEntry myBlogEntry = myBlogEntryEntity.getEntry();
myBlogEntry.setTitle(new AtomText("Title"));
AtomContent content = new AtomContent();
content.setType("text");
content.setValue("Some Content");
myBlogEntry.setContent(content);

// Create a Resource that will represent a single blog entry
Resource blogResource = restClient.newResource(postUrl);

// Publish a new blog entry
Response<AtomEntryEntity> response = blogResource.doPost(myBlogEntry, AtomEntryEntity.class);
AtomEntry post = response.getEntity().getEntry();  
+-----------------------------------------

  * <<Note>>: Prior to publishing a new blog entry, the client has to be authenticated against a Google "ClientLogin" service. 
    An example of how to perform this with a Symphony REST Client can be found in the {{Handlers}} section.
	
  []

** {Introspection of an Atom Service Document}
 
  These example applications provides a complete code reference of how the service is "discovered" using the Symphony Rest Client. 
  Discovery refers to retrieving the service workspaces and their collections, and printing all of
  the collection URL's and the their accepted representations.

+-----------------------------------------
package com.hp.demo;

import org.hp.symphony.rest.client.Resource;
import org.hp.symphony.rest.client.Response;
import org.hp.symphony.rest.client.RestClient;
import org.hp.symphony.rest.client.entities.AtomServiceEntity;
import org.hp.symphony.rest.model.app.AppService;
import org.hp.symphony.rest.model.app.AppWorkspace;
import org.hp.symphony.rest.model.app.AppCollection;

public class DiscoverService {

	public static void main(String[] args) {
		
		// create the client instance
		RestClient client = new RestClient();
		
		// create the resource instance to interact with
		Resource resource = client.newResource("http://12.34.56.78:8080/some/service");

		// get the service document
		Response<AppServiceEntity> response = resource.doGet(AppServiceEntity.class);

		// work with the service document
		AppService service = response.getEntity().getService();
		
		List<AppWorkspace> workspaces = service.getWorkspace();
		
		for (AppWorkspace ws : workspaces) {
			System.out.println("Workspace: " + ws.getTitle().getValue());
			
			List<AppCollection> collections = ws.getCollection();
			
			for (AppCollection collection : collections) {
				System.out.println("    Collection: " + collection.getTitle().getValue());
				System.out.println("        Href  : " + collection.getHref());
				
				System.out.print("        Accept: ");
				List<AppAccept> accepts = collection.getAccept();
				for (AppAccept accept : accepts) {
					System.out.print(accept.getValue() + ", ");
				}
				System.out.println();
			}
		}
	}
}
+-----------------------------------------

  The result of running this example application might appear as follows:
  
+-----------------------------------------
Workspace: QA Defects
    Collection: Defects
        Href  : http://12.34.56.78:8080/some/service/defects
        Accept: application/atom+xml, application/xml, text/csv, 
    Collection: Tests of Defect
        Href  : http://12.34.56.78:8080/some/service/defects/{defect}/tests
        Accept: 
    Collection: Tests
        Href  : http://12.34.56.78:8080/some/service/tests
        Accept: 
+-----------------------------------------
  
** {Exploring Atom Feed and Atom Entry}

  This example demonstrates the retrieval of Atom feeds, iterating through their entries 
  and printing each entry title.
  
+-----------------------------------------
package com.hp.demo;

import java.util.Iterator;

import org.hp.symphony.rest.client.Resource;
import org.hp.symphony.rest.client.Response;
import org.hp.symphony.rest.client.RestClient;
import org.hp.symphony.rest.client.entities.AppServiceEntity;
import org.hp.symphony.rest.client.entities.AtomFeedEntity;
import org.hp.symphony.rest.model.atom.AtomEntry;
import org.hp.symphony.rest.model.atom.AtomFeed;
import org.hp.symphony.rest.model.app.AppService;
import org.hp.symphony.rest.model.app.AppWorkspace;

public class ExploreFeeds {

	private static RestClient client;
	private static String COLL_DEFECT = "Defects";
	private static String COLL_TESTS  = "Tests";
	
	public static void main(String[] args) {

		client = new RestClient();
	
		// create the resource instance to interact with
		Resource resource = client.newResource("http://12.34.56.78:8080/some/service");

		Response<AppServiceEntity> response = resource.doGet(AppServiceEntity.class);

		AppService text = response.getEntity().getService();
		
		AppWorkspace ws = text.getWorkspace().get(0);
		
		System.out.println("Workspace : " + ws.getTitle().getValue());
		
		explore(COLL_DEFECT, ws.getCollection(COLL_DEFECT).getHref());
		explore(COLL_TESTS, ws.getCollection(COLL_TESTS).getHref());
	}

	private static void explore(String collectionName, String href){
						
		Resource feedResource = client.newResource(href);
		Response<AtomFeedEntity> feedResponse = feedResource.doGet(AtomFeedEntity.class);
		AtomFeed feed = feedResponse.getEntity().getFeed();
		List<AtomEntry> entries = feed.getEntry();
		
		System.out.println("    " + collectionName + " Feed (Number of " + collectionName + ": " + entries.size() + ")");
		
		Iterator<AtomEntry> itEntry = entries.iterator();
		
		while (itEntry.hasNext()) {
			System.out.println("        " + itEntry.next().getTitle().getValue());
		}
	}
}
+-----------------------------------------
  
  The exploration of the feeds may result in an overview as follows:
  
+-----------------------------------------
Workspace : QA Defects
    Defects Feed (Number of Defects: 3)
        Cancel button is missing
        Login failure
        Cannot perform payment
    Tests Feed (Number of Tests: 3)
        Payment Services
        Login as admin
        Shutdown application
+-----------------------------------------

* {Handlers}

  The Symphony Client provides the ability to easily plug-in cross application functionality by using <Handlers>. 
  A handler class implements the <<<Handler>>> interface by implementing the <<<handle()>>> method.
  All registered handlers on a client are invoked for every request made by the client, and in the order that they were registered. 
  Handlers provide the opportunity to manipulate the outgoing request headers and body before they are actually sent, 
  and to manipulate the incoming response headers and body before they are passed back to the application.
  
  * <<Note>>: In this example the <<<PhaseAwareHandler>>> is extended, but the basic handler is the <<<Handler>>> interface. 
    <<<PhaseAwareHandler>>> simplifies the development of handlers

  []
	
  The following is an example of a handler that authenticates all outgoing requests againts a Google "ClientLogin" Service.
  
+-----------------------------------------
/**
 * GoogleAuthenticationHandler - authenticate against "GoogleLogin" Service
 */
public class GoogleAuthenticationHandler extends PhaseAwareHandler {

  private static final String AUTHORIZATION = "Authorization";

  @Override
  // This method is invoked before sending Http Request Headers.
  // Notice: Http Request Headers are sent prior to the body. 
  //         After the body is sent, Http Request Headers can not be modified.
  public void handleRequestHeaders(RequestContext requestContext) {
    if(requestContext.getHeader(AUTHORIZATION) == null) {
      // Call private method to get Google Authentication Token
      String googleAuthToken = acquireGoogleAuthToken();
	  // Add Google Authentication Token as Http Request Header
	  requestContext.setHeader(AUTHORIZATION, "GoogleLogin auth=" + googleAuthToken);
    }
  }
}
+-----------------------------------------
  
  For more information about the Google "ClientLogin" Service refer to the {{Appendix}}
  
  Now register the new handler. This can be performed either from the code, or in a configuration file. 
  The following example shows how to register GoogleAuthenticationHandler from the code.
  
+-----------------------------------------
Configuration configuration = new Configuration();
// Add Google Authentication Handler
configuration.addHandler(GoogleAuthenticationHandler.class, null);

// Create Rest Client
 RestClient restClient = new RestClient(configuration);

// Work with client as usual...  
+-----------------------------------------

* {Configuring the Client}
  
  Client configuration is possible through code or through a configuration file.

** Configuration through code

  Configuring the client through code is performed by creating a Configuration object, and passing it to the constructor of a RestClient. 
  For more information on the Configuration class, refer to  
  {{{http://buildbox.devlab.ad/bcd/rest-sdk/last-success/code/client/target/site/apidocs/index.html}API}}
  
  Here is an example
  
+-----------------------------------------
// create the configuration object
Configuration configuration = new Configuration();

// set configuration parameters, for example,set a proxy named proxyServer on port 6565
configuration.setProxy("proxyServer", 6565)

// Create the Rest Client and pass it the configuration
 RestClient restClient = new RestClient(configuration);

// Work with client as usual...
+-----------------------------------------

** Configuration through a file

  Configuring the client through a configuration file is performed by creating a Configuration object and 
  passing it an input stream to read the configuration.
  
  Here is an example
  
+-----------------------------------------
// create an input stream
FileInputStream is = new FileInputStream("client-configuration-file.xml");

// create the configuration object and pass it the input stream to load from
Configuration configuration = new Configuration(is);

// Create the Rest Client and pass it the configuration
 RestClient restClient = new RestClient(configuration);

// Work with client as usual...
+-----------------------------------------

*** Configuration file structure

  Here is the complete structure of the configuration file
  
+-----------------------------------------
<rest-client-config xmlns="http://hp.com/2008/1/rest/client/conf">
  <!-- optional. configure a proxy that the client should connect through. all attributes are mandatory -->
  <proxy host="localhost" port="8081"/>

  <!-- optional. configure connect and read timeouts in milliseconds. all attributes are mandatory -->
  <timeouts connect="10000" read="10000"/>
  
  <!-- optional. configure redirection: -->
  <!-- 'follow' (required): enable or disable redirection altogether --> 
  <!-- 'methods' (optional): comma separated list of HTTP methods to redirect, e.g. methods="GET,DELETE". 
  							 if omitted, all methods are redirected --> 
  <redirect follow="true|false" methods="GET,PUT,POST,DELETE"/>
  
  <!-- optional. configure the handler chain. the order of handlers that will run is the same as defined here -->
  <handler-chain>
    <!-- define a handler -->
    <handler handler-class="com.hp.example.ExampleHandler1">
      <!-- optional. supply init properties for the handler -->
      <property key="IsExample">true</property>
      <property key="ExampleNumber">1</property>
    </handler>
    <handler handler-class="com.hp.example.ExampleHandler2"/>
  </handler-chain>
</rest-client-config>
+-----------------------------------------
  
* Writing an Entity

  It is possible to write your own entity to serialize and deserialize the request body and response body.
  The entity class writen must extend the Entity abstract class and be annotated with the MimeType annotation to 
  specify the mime type that this entity will be handling.

  The entity class must implement two methods:
  
  * <<<public void writeTo(OutputStream os, ClientContext context) throws IOException>>>
  
    for serializing the entity during serialization of the HTTP request body
  
  * <<<public void readFrom(InputStream is, ClientContext context) throws IOException>>>
  
    for deserializing the entity during deserialization of the HTTP response body  

  []
	
  Here is an example
  
+-----------------------------------------
@MimeType("text/plain")
class MyTextEntity extends Entity {
  private String text;

  public String getText() {return text;}
  public vois setText(String text) {this.text = text;}
  @Override
  public void writeTo(OutputStream os, ClientContext context) throws IOException {
    os.write(text.getBytes());
  }
  
  @Override
  public void readFrom(InputStream is, ClientContext context) throws IOException {
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    int readBytes = 0;
    byte[] tempBytes = new byte[4096];
    while ((readBytes = is.read(tempBytes)) != -1) {
      os.write(tempBytes, 0, readBytes);
    }
    text = new String(os.toByteArray());
  }
}  
+-----------------------------------------
 
* {Appendix}

** Google ClientLogin Authenication

  The following code example shows how to acquire the Google Authentication Token. 
  For more info refer to {{{http://code.google.com/apis/blogger/developers_guide_protocol.html#Auth}Google Developers Guide}}
  
+-----------------------------------------
/**
* Get Google Authentication token.
* @param authTokensString
* @return token
*/
public String acquireGoogleAuthToken() {
String authToken ="";
  try {
    URL url = new URL("https://www.google.com/accounts/ClientLogin");
    RestClient restClient = new RestClient();
    Resource googleAuthServiceResource = restClient.newResource(url);

    // Create Auth Request - Use TestEntity to retrieve authentication token
    TextEntity authRequest = new TextEntity();
    authRequest.setMimeType("application/x-www-form-urlencoded");
    authRequest.setText("accountType=GOOGLE&Email=johnsmith@gmail.com"\+
    "&Passwd=12345&service=blogger&source=Gulp-CalGulp-1.05");
    // Get Auth Token. The response is returned plain text
    Response<TextEntity> authTokens = googleAuthServiceResource.doPost(authRequest, TextEntity.class);
    String authTokensString = authTokens.getEntity().getText();

    authToken = extractAuthToken(authTokensString);
  } catch (Exception e) {
     e.printStackTrace();
  }
  return authToken;
}

/**
* Extract Google Authentication token
* @param authTokensString
* @return token
*/
private String extractAuthToken(String authTokensString) {
  StringTokenizer tokenizer = new StringTokenizer(authTokensString, "=\n");
  String token = null;
  while (tokenizer.hasMoreElements()) {
    if (tokenizer.nextToken().equals("Auth")) {
      if (tokenizer.hasMoreElements()) {
        token = tokenizer.nextToken();
      }
      break;
    }
  }
  return token;
}
+-----------------------------------------
	
